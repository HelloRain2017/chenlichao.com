---
layout: post
title: job-control
description: job-control
---

Unix Job Control
================

Intro
-----

<http://en.wikipedia.org/wiki/Job_control_(Unix)>

When using Unix or related operating systems via a terminal, a user will initially only have a single process running, their login shell. Most tasks (directory listing, editing files, etc.) can easily be accomplished by letting the program take control of the terminal and returning control to the shell when the program exits; however, sometimes the user will wish to carry out a task in the background while using the terminal for another purpose. Job control is a facility developed to make this possible.

具体实现：

Typically, the shell keeps a list of jobs in a job table. A job consists of all the *members of a pipeline* ; thus all the processes constituting the job will be in the same *process group* .

A program can be started as a background task by appending "&" to the command line; its *output is directed to the terminal* (potentially interleaved with other programs' output) but it cannot read from the terminal input.

A task running in the foreground can be stopped by typing the suspend character (Ctrl-Z); this sends SIGTSTP to the *process group* and returns control to the shell.

A stopped job can be resumed as a background job with the `bg` builtin or as the foreground job with `fg`; in either case the shell redirects I/O appropriately and sends *SIGCONT* to the process.

`jobs` will list the background jobs existing in the job table, along with their job number and job state (stopped or running).

The kill builtin (not /bin/kill) can signal jobs by job ID as well as by process ID: jobs specified by a job ID should be killed by prefixing "%". Kill can send any signal to a job, however if the intent is to rid the system of the processes the signals SIGKILL and SIGTERM (the default), are probably the most applicable. A task running in the foreground can be permanently suspended by typing the kill character (Ctrl-C).

`disown` can be used to remove jobs from the job table, converting them from jobs into daemons so that they continue executing when the user logs out.

Related Unix Signals
--------------------

<http://en.wikipedia.org/wiki/Unix_signal>

SIGTSTP

The SIGTSTP signal is sent to a process by its controlling terminal to request it to stop temporarily. It is commonly initiated by the user pressing Control-Z. Unlike SIGSTOP, the process can register a signal handler for or ignore the signal.

SIGCONT

The SIGCONT signal instructs the operating system to continue (restart) a process previously paused by the SIGSTOP or SIGTSTP signal. One important use of this signal is in job control in the Unix shell.

SIGTTIN and SIGTTOU

The SIGTTIN and SIGTTOU signals are sent to a process when it attempts to read in or write out respectively *from the tty while in the background* . Typically, this signal can be received only by processes under job control; daemons do not have *controlling terminals* and should never receive this signal.

SIGINT

The SIGINT signal is sent to a process by its controlling terminal when a user wishes to interrupt the process. This is typically initiated by pressing Control-C, but on some systems, the "delete" character or "break" key can be used.

Cheatsheet
----------

+   & 將命令作为后台任务执行
+   Ctrl-Z 将前台任务挂起中断,并丢到jobs table中
+   Ctrl-C 将前台任务强制结束
+   jobs 查看jobs table
+   %jn 表示第n个job；%% 表示当前的job
+   fg %jn 将jobs table中已停止的任务放入前台继续执行
+   bg %jn 将jobs table中已停止的任务在后台中继续执行，但如果stdout原先指向终端，之后依然指向终端
+   kill -CONT pid 将已停止并disown的任务在后台继续执行

参考: <http://www.thegeekstuff.com/2010/05/unix-background-job/>

Process Group
-------------

<http://en.wikipedia.org/wiki/Process_group>

Process groups are used to control the *distribution of signals* . A signal directed to a process group is delivered individually to all of the processes that are members of the group.

Process groups are themselves grouped into *sessions* . Process groups are not permitted to migrate from one session to another, and a process may only create new process groups belonging to the same session as it itself belongs to. Processes are not permitted to join process groups that are not in the same session as they themselves are.

New process images created by a call to a function of the *exec* family *inherit* the *process group membership* and the *session membership* of the old process image.

The distribution of signals to process groups forms the basis of job control employed by shell programs.

1.  The *tty device* driver incorporates a notion of a foreground process group, to which it sends the SIGTSTP, SIGQUIT, and SIGINT signals generated by keyboard interrupts.

2.  It also sends the SIGTTIN and SIGTTOU signals to any processes that attempt to read from (and, if appropriate flags are set for the terminal device, write to) the *terminal* and that *are not in the foreground process group* .

The *shell* , in turn, partitions the command pipelines that it creates into process groups, and controls what process group is the *foreground process group of its controlling terminal* , thus determining what processes (and thus what command pipelines) may *perform I/O to and from the terminal* at any given time.

The system call setsid() is used to create a new session containing a single (new) process group, with the current process as both the session leader and the process group leader of that single process group. Process groups are identified by a positive integer, *the process group ID, which is the process identifier of the process that is (or was) the process group leader.* Process groups need not necessarily have leaders, although they always *begin with one.* *Sessions are identified by the process group ID of the session leader.* POSIX prohibits the change of the process group ID of a session leader.

The system call setpgid() is used to set the process group ID of a process, thereby either joining the process to an existing process group, or creating a new process group within the session of the process with the process becoming the process group leader of the newly created group. POSIX prohibits the re-use of a process ID where a process group with that identifier still exists (i.e. where the leader of a process group has exited, but other processes in the group still exist). It thereby *guarantees that processes may not accidentally become process group leaders* .

The system call kill is capable of directing signals either to individual processes or to process groups.

* * * * * * * * * * * * * * * * * * * * 

In computing, a login session is the period of activity between a user logging in and logging out of a (multi-user) system.

On Unix and Unix-like operating systems, a login session takes one of two main forms:

1.  When a textual user interface is used, a login session is represented as a *kernel session* — a collection of process groups with the logout action managed by a session leader. Kernel sessions are used to implement login sessions. A single process, the session leader, interacts with the controlling terminal in order to ensure that all programs are terminated when a user "hangs up" the terminal connection. (Where a session leader is absent, the processes in the terminal's foreground process group are expected to handle hangups.)

2.  Where a graphical user interface is being used, the session concept is largely lost, and the kernel's notion of sessions largely ignored. Graphical user interfaces, such as where the X display manager is employed, use a different mechanism for implementing login sessions. A login session is considered to be the lifetime of a designated user process that the display manager invokes.
